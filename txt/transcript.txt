 Hola a todo el profesorado que está al otro lado de la pantalla. Muchas gracias de antemano por vuestra atención. Soy Elisa García y os voy a presentar el trabajo que he realizado para el proyecto final de ciclo. Antes de explicar en qué consiste mi aplicación, quiero contaros por qué surgió la idea que me ha llevado a desarrollarla. Os presento estas dos imágenes. Si nos acercamos a la primera, visualmente os puede transmitir muchas cosas. Todo dependerá de los ojos que la observan. En mi caso me transmite fantasía, tranquilidad, pero otra persona puede sentir miedo, soledad, tristeza. ¿Pero qué sucede si le añadimos un recurso musical? El contexto cambia, nos transmite otras sensaciones y nos sumerge en la historia que hay detrás de la imagen. Aventura, riesgo, lucha... Pues lo mismo sucede con los juegos de mesa. Suena algo estático que nosotros le damos un contexto. En la imagen se ven copas de vino para jugar a un juego de investigación y esa recreación ambiental también se consigue gracias a la música. Y así surgió la idea de crear Board Games Music, una aplicación web de búsqueda de música ambiental para juegos de mesa. Entre otras cosas, ¿por qué surgió la idea? porque actualmente no existe una web que automatice el proceso de búsqueda para añadir una experiencia sensorial en la recreación de ambiente y para mejorar lo que ya existe. Para desarrollar esta aplicación, la tecnología elegida ha sido Angular. Entiendo que ya conocido por todos vosotros, pero únicamente quiero decir que es un framework creado por Google para desarrollar aplicaciones en TypeScript. ¿Por qué me interesó aprenderlo? Primero, porque durante el curso ya aprendimos RIA y dado que ambas tecnologías son muy demandadas por las empresas, quería tener noción de ambas. A continuación, os presento un gráfico y una tabla. En la tabla está sacada de stacktrends.org. Es a nivel de Estados Unidos y nos muestra un ranking de los frameworks más demandados analizando ofertas de empleo. Se observa que las ofertas de empleo en Estados Unidos de Angular y React están por encima de cualquier otro framework. La tendencia de UE está subiendo, a la par que baja Angular, pero en datos absolutos las más demandadas son Angular y React. También esta gráfica de Stack Overflow muestra las tendencias de las consultas que hacen los desarrolladores en su página. Se ve claramente cómo React continúa con una tendencia creciente. WEE crece, pero no llega a ser significativo al nivel de Angular y RA Puede que en algún momento sí llegue a ser WEE JQuery cae bruscamente Y Angular actualmente se mantiene y cae a la par que crece WEE, pero sigue por encima Por eso considero importante, al menos durante la etapa tecnológica actual, tener conocimientos de Android En esta diapositiva quiero mostraros el flujo de datos de la aplicación La aplicación consta de tres servicios la API de Borden Atlas para buscar juegos de mesa. Esos juegos llevan asociadas unas categorías que utilizaremos como palabras clave en la búsqueda de libros en la API de YouTube. Por otro lado, se encuentra el servicio de autenticación de usuario de Google para hacer peticiones a YouTube con el token de usuario. El proyecto consta de dos páginas principales, el buscador y el reproductor de música, y ambas páginas comparten los componentes cede y input. El buscador será la página principal de la aplicación y contiene el componente input que es el propio buscador Por otro lado tenemos la p de m que contiene el componente reproductor Este ser el encargado de gestionar todo lo relacionado con YouTube Desde la página del buscador el usuario se loguea y se gestionan las llamadas a la API Board in Atlas para obtener el listado de juegos. Una vez seleccionado el juego por parte del usuario, se navega a la página de música. la cual será la encargada de hacer la petición a YouTube con el token de usuario para obtener los IDs de música. Y ahora os voy a mostrar la aplicación web en funcionamiento. Esta es la página principal de la aplicación. Como podéis ver, es completamente responsive. Desde el input iniciamos la búsqueda de un juego. Como no estamos logueados, nos va a dar el aviso de que por favor nos logueemos Hacemos clic en Login y nos logueamos con Google Como veis aparece nuestro usuario y ya podemos iniciar la búsqueda que nos llevará a la siguiente página Este es el reproductor Como podéis ver tenemos los distintos controles Podemos pausar la canción Continuar escuchándola Y movernos a lo largo del slider También podemos pasar de canción Si hacemos clic en el título, volvemos a la página del buscador y podemos iniciar la búsqueda de otro juego. Si hacemos clic en Logout, nos aparece el aviso de que volvamos pronto y volvemos a la página de inicio. A continuación entramos en la parte de código. Cuando creas un proyecto en Angular, se realiza con el comando ng1. Añades el nombre del proyecto y los parámetros opcionales que requieras. Quiero destacar estos dos cucheros que se crean automáticamente, que serán la base inicial de nuestra aplicación. Aquí añadir que para crear un componente o un servicio automáticamente en Angular se pueden ejecutar los siguientes comandos que os muestro en pantalla En este fichero autogenerado por Angular encontramos en los módulos todos los módulos que utilizas en tu aplicación Sería como un índice de su contenido En declarations se agregan los componentes que has creado En Imports añades los módulos o librerías externas u otros módulos de tu aplicación. Otro fichero que nos genera Angular es el fichero de app. Aquí encontramos todas las rutas que vamos a utilizar en nuestra aplicación y el componente asociado a estas rutas, es decir, el componente que se va a aplicar. Y finalmente, AppComponent. AppComponent es el componente principal de nuestra aplicaci y como veis contiene tres tipos de cicheros el HTML el CSS y el CSS En este caso es el CSS. Aquí aprovecho para explicaros también lo que es un selector en Android. Un selector son etiquetas que corresponden a cada componente de tu aplicación, parecidas al HTML. Y cada etiqueta contiene el fragmento de código de su componente. Como podéis ver en el HTML del componente principal, tengo los selectores del header y del booter, dado que son componentes compartidos entre todas las páginas. Y aquí tenemos router outlet. En router outlet se pintan los componentes que se encuentran en el fichero routing que os he explicado anteriormente. Otra parte importante de Angular es la comunicación entre componentes. De padre a hijo con arroba input. De hijo a padre, con arroba output y entre hermanos. Se utilizan servicios. En primer lugar, la comunicación de padre a hijo. Tenemos un componente padre, que en este caso es Music Component. Y un componente hijo, que es el reproductor de música. Sabemos que es su hijo porque contiene este lector. Desde Music Component queremos enviar datos a hijo. Y para indicar que el hijo espera esos datos, se crea la propiedad arroba input por cada dato que espera. Finalmente, señalan las variables desde el componente padre al hijo asociadas a cada propiedad. Por otro lado, tenemos la comunicación de hijo a padre. ¿Cómo se comunica un hijo con su padre? En este caso, el padre es el check component, que contiene el componente hijo input component. ¿Cómo lo sabemos? De nuevo, porque el padre contiene el selector que corresponde al hijo, que es appInput. Os quiero mostrar cómo al hacer foco en el input, el padre recibe la orden de elevar la caja. Este efecto te ves en pantalla. ¿Cómo enviar el hijo información a su padre? Vamos a ir paso a paso. Primero, veamos el objeto arroba output en el hijo que manda el mensaje. Este será el encargado de enviar el aviso al padre cuando se le ordene. En segundo lugar, cuando el input recibe el foco, se llama su función a un foco. Esta función setea una propiedad interna a truth y ordena al arroba output con su propiedad en if de que avise al padre del campo, enviándole la variable setea. Cuando se produce el aviso, el padre recoge en una función lo que se le envía desde el hijo. Setea una variable suya para poder usarla cuando se produce ese cambio en el estado de la variable. Y el contenedor, con la directiva ng-class, dependiendo de esa variable, modifica la clase y eleva el contenedor. ¿Cómo se comunican los hermanos? En este caso, G de RouterAulet y FUTO son hermanos. Pertenecen todos al mismo padre, appComponent. Os recuerdo que en RouterAulet se pintan los componentes que indiquen en el fichero appRoot. En nuestro caso, la página principal es Searcher y la página secundaria es User. En la aplicación, el usuario se loguea a través de Google y se ha insertado el logueo en el componente Azure. Como podéis ver, el componente está suscrito a un servicio de un módulo de autenticación que proporciona el usuario. Como el usuario es necesario para hacer comprobaciones en los componentes hermanos, he preferido crear un servicio común en el que se quedó la variable User, así que está disponible el usuario para cualquier componente. Desde Music Component se puede comprobar si el usuario está logueado y si no es así se reenvía a la página principal y desde Input para avisar de que se loguee en caso de mostrarlo. Por tanto, hemos visto que los servicios sirven tanto para guardar como para recuperar datos entre componentes, pero tambi sirven para tratar datos con APIs externas Mediante el protocolo HTTP se realizan operaciones fluidos como en el caso pr que os voy a mostrar Por ejemplo en el proyecto he creado dos servicios Uno encargado de hacer peticiones a la API de Borda y Naldas, para poder pintar así el listado de juegos cuando se estuve en el input, y también para coger las categorías del juego seleccionado al hacer clic. Esas categorías serán las que permitan hacer la búsqueda en YouTube, que será el segundo servicio. Por ejemplo, al hacer una búsqueda del juego Concordia obtenemos una raya de objetos con las categorías que podéis ver. No todas serán adecuadas, por lo que en la aplicación también se han descartado categorías cuyos resultados de búsqueda en YouTube no eran buenos. En este servicio ya hemos guardado el objeto juego y el objeto categorías. Y finalmente, el servicio de YouTube. ¿Qué es interesante en el servicio de YouTube? Que se utiliza el token de usuario que nos proporciona Google para poder utilizar la API de YouTube sin limitación. ¿Por qué sin limitaciones? Porque al utilizar la API Key, el número de peticiones a YouTube era muy, muy limitado y por eso tomé la decisión de utilizar el token de usuario de Google. En segundo lugar, también es interesante las palabras clave que se utilizan para la búsqueda de vídeos en YouTube La propia cabecera de la petición Getalapy de YouTube con el token de usuario y la llamada YouTube Quería hablar en particular del componente reproductor de música porque en un principio fue complejo de implementar Youtube nos da una idea que nos permite cargar en un iframe tanto audio como video. Como solo necesito el audio, se ha ocultado la parte del video del iframe. Y en su lugar he utilizado una imagen del juego elegido que se recupera desde el objeto guardado en Game Service. Además, para crear el reproductor de música, he utilizado una librería que permite manipular el iframe de Youtube. El reproductor recibe un array de IDES de su padre Music Compone, que es el encargado de llamar a la API de YouTube. Cuando el componente Media Player se pinta en el DOM, ya dispone del array de IDES y se inicializa la variable con el ID que se va a reproducir. Como ya disponemos tanto de los IDES de los vídeos que queremos reproducir como de la librería para tratar con el eFrame de YouTube, se pueden crear funciones que permiten manipular tu propio reproductor. como podéis ver, play, pause, etc. Este componente es un poco más complejo de lo que os he explicado, debido a que hay que tratar con estados numéricos que devuelve la API. Os explico un poco a nivel general con algunos ejemplos. Para saber en qué momento se encuentra el vídeo que se está reproduciendo, nos suscribimos a un observable del servicio que nos proporciona el estado. Por ejemplo, el estado 3 nos indica que la canción ha finalizado. En ese momento llamamos a la función que cambia el ID que se va a reproducir. Y finalmente, la API devuelve el tiempo de la canción en su nombre. Para poder pintar el formato correcto, se modifica con la siguiente función. Y ya para finalizar, ¿cuáles son las conclusiones generales que he sacado? Que Angular permite un código organizado y reutilizado. La facilidad de aprendizaje si conoces otros frameworks como RIA. Y las directivas que permiten un código bastante limpio. que no me ha gustado, que la pide YouTube es muy limitada, que es obligatorio usar OAuth para realizar peticiones sin limit en YouTube y que las librerías disponibles en Angular son menos geniales. Y ya para finalizar, mostraros la documentación que he consultado durante el desarrollo de la aplicación. Y daros las gracias por vuestra atención durante estos minutos. Ha sido un placer y espero que os haya gustado. Gracias.